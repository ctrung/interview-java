# java-generics

[<< summary](../README.md)

##### Raw types allowed but compilation won't detect runtime errors
```java+
List<String> stringList = ...

List rawList = stringList; // warning: unchecked conversion
rawList.add(1); // warning: unchecked call

for (String s : stringList) { ... } // java.lang.ClassCastException
```

##### Multiple bounded types allowed but class must be declared before interfaces
```java
Class A { /* ... */ }
interface B { /* ... */ }
interface C { /* ... */ }

class D <T extends B & A & C> { /* ... */ }  // compile-time error
```

##### Inheritance pitfall 
`Box<Integer>` is not a subtype of `Box<Number>` even though `Integer` is a subtype of `Number`
```java
public void boxTest(Box<Number> n) { /* ... */ }

Box<Integer> intBox = ...
boxTest(intBox) // compile-time error
```

##### Bridge methods
These are introduced during type erasure to ensure polymorphism
```java
public class Node {

    public Object data;

    public Node(Object data) { this.data = data; }

    public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node {

    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```
after type erasure, it becomes
```java
class MyNode extends Node {

    // Bridge method generated by the compiler
    //
    // java.lang.ClassCastException might occur in Runtime : stacktrace will point out to this method but at line where this class is declared !
    public void setData(Object data) {
        setData((Integer) data);
    }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }

    // ...
}
```

##### Non-Reifiable Types
A reifiable type is a type whose type information is fully available at runtime. This includes primitives, non-generic types, raw types, and invocations of unbound wildcards.

Non-reifiable types are types where information has been removed at compile-time by type erasure.

##### Heap pollution
Heap pollution occurs when a variable of a parameterized type refers to an object that is not of that parameterized type.
This situation occurs if the program performed some operation that gives rise to an unchecked warning at compile-time.

##### Potential Vulnerabilities Varargs Methods with Non-Reifiable Formal Parameters
It will generate a heap pollution warning at the vargargs method declaration
```java
public static <T> void addToList (List<T> listArg, T... elements) { // warning: [varargs] Possible heap pollution from parameterized vararg type T
    // the code below is fine
    for (T x : elements) {
        listArg.add(x);
    }
}

public static void faultyMethod(List<String>... l) { // warning: [varargs] Possible heap pollution from parameterized vararg type T
    // the code below is bad
    Object[] objectArray = l;     // Valid
    objectArray[0] = Arrays.asList(42);
    String s = l[0].get(0);       // ClassCastException thrown here
}
```

##### Arrays
The component type of an array object may not be a type variable or a parameterized type, unless it is an (unbounded) wildcard type. 
You can declare array types whose element type is a type variable or a parameterized type, but not array objects.

```java
// not allowed
List<String>[] lsa = new List<String>[10]; 

// OK, array of unbounded wildcard type.
List<?>[] lsa = new List<?>[10];

// Error.
List<String>[] lsa = new List<?>[10];
```

##### Generics restrictions

* Cannot Instantiate Generic Types with Primitive Types

* Cannot Create Instances of Type Parameters
```java
public static <E> void append(List<E> list) {
    E elem = new E();  // compile-time error
    list.add(elem);
}
```
as a workaround
```java
public static <E> void append(List<E> list, Class<E> cls) throws Exception {
    E elem = cls.newInstance();   // OK
    list.add(elem);
}
```

* Cannot Declare Static Fields Whose Types are Type Parameters

Because a static field is common to all instance of the class, if it were allowed, for different type parameters, the static field would have multiple types at the same time.

* Cannot Use Casts or instanceof With Parameterized Types

* Cannot Create Arrays of Parameterized Types

* Cannot Create, Catch, or Throw Objects of Parameterized Types

A generic class cannot extend the Throwable class directly or indirectly. For example, the following classes will not compile:
```java
// Extends Throwable indirectly
class MathException<T> extends Exception { /* ... */ }    // compile-time error

// Extends Throwable directly
class QueueFullException<T> extends Throwable { /* ... */ // compile-time error
```

A method cannot catch an instance of a type parameter:
```java
public static <T extends Exception, J> void execute(List<J> jobs) {
    try {
        for (J job : jobs)
            // ...
    } catch (T e) {   // compile-time error
        // ...
    }
}
```

You can, however, use a type parameter in a throws clause:
```java
class Parser<T extends Exception> {
    public void parse(File file) throws T {     // OK
        // ...
    }
}
```

* Cannot Overload a Method Where the Formal Parameter Types of Each Overload Erase to the Same Raw Type


